*remote_plugin.txt*    Nvim


			    NVIM REFERENCE MANUAL


Nvim support for remote plugins			  *remote-plugin*

				      Type |gO| to see the table of contents.

==============================================================================
Remote Plugins					*remote-plugin-intro*

Extensibility is a primary goal of Nvim. Any programming language may be used
to extend Nvim without changes to Nvim itself. This is achieved with remote
plugins, coprocesses that have a direct communication channel (via |RPC|) with
the Nvim process.

Even though these plugins run in separate processes they can call, be called,
and receive events just as if the plugin's code were executed in the main
process.

==============================================================================
Remote Plugins v2

Remote plugins were redesign to be 10x simpler. The original design is
described in |rplugin-deprecated|.

Unlike the orignal "v1" design, remote plugins are now literally just regular
Lua plugins that call node/python/ruby/etc. All the benefits of remote
plugins, with none of the extra concepts.

To create the "remote" part of the plugin, you just:
1. write a module in your preferred language (javascript/typescript/python/etc)
2. make sure the module has a main function, so Nvim can load the module and
   attach (create a channel) to it.

v2 remote plugins vs v1:
- no more `neovim-node-host`. Node provider works just like python: all it
  needs is `node`.
- install "neovim" somewhere at the root of your plugins directory.
- no more "plugin manifest", no more :UpdateRemotePlugins
- no more rplugin/ directory. Your plugin is just a normal Lua plugin that
  happens to create a RPC channel that loads your custom module.
- no more "plugin host" concept. Instead, your remote plugin is just a normal
  module with a main method that Nvim can start and attach to. And to do that,
  your module imports the relevant Nvim API client library.
- the Lua part of your plugin defines commands/autocmds/functions that call
  your remote methods. Nvim doesn't do that for you. (This avoids the need for
  :UpdateRemotePlugins).

CAVEATS:
- your Lua code which starts the remote process needs to avoid re-creating the
  process. Just like you can "spam" event handlers, you want to avoid spamming
  a bunch of processes. Instead, your plugin should share one channel
  internally and use that to call methods on the remote process.
  - TODO: provide a function that lazy-loads the remote client


Guidelines for API clients:
- provide setHandler() so that plugins can define method/notification
  handlers.
- provide cli() so that plugins can easily let Nvim invoke the "main" and
  attach to stdio.

==============================================================================
OLD Example					    *remote-plugin-example*

The best way to learn about remote plugins is with an example, so let's see
what a Python plugin looks like. This plugin exports a command, a function, and
an autocmd. The plugin is called 'Limit', and all it does is limit the number
of requests made to it. Here's the plugin source code: >python

    import pynvim

    @pynvim.plugin
    class Limit(object):
        def __init__(self, vim):
            self.vim = vim
            self.calls = 0

        @pynvim.command('Cmd', range='', nargs='*', sync=True)
        def command_handler(self, args, range):
            self._increment_calls()
            self.vim.current.line = (
                'Command: Called %d times, args: %s, range: %s' % (self.calls,
                                                                   args,
                                                                   range))

        @pynvim.autocmd('BufEnter', pattern='*.py', eval='expand("<afile>")',
                        sync=True)
        def autocmd_handler(self, filename):
            self._increment_calls()
            self.vim.current.line = (
                'Autocmd: Called %s times, file: %s' % (self.calls, filename))

        @pynvim.function('Func')
        def function_handler(self, args):
            self._increment_calls()
            self.vim.current.line = (
                'Function: Called %d times, args: %s' % (self.calls, args))

        def _increment_calls(self):
            if self.calls == 5:
                raise Exception('Too many calls!')
            self.calls += 1
<


==============================================================================
 vim:tw=78:ts=8:noet:ft=help:norl:
